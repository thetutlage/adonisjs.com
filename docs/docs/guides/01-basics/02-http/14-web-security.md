---
permalink: guides/http/web-security
category: Handling HTTP Requests
group: Basics
---

# Web Security
AdonisJS has a strong emphasis on security. We make sure that the core of the framework is free all known vulnerabilities and also provide you with enough tools to keep your applications secure from common web attacks.

By the end of this guide, you will know:

- How to keep form submissions secure using CSRF protection
- How to protect your websites from XSS attacks
- And other baked in security features of AdonisJS

## Setup
All of the security guards are implemented by a first party package `@adonisjs/shield`. This package is pre-configured for Web application boilerplate created using `npx` or `yarn create`. 

Open `.adonisrc.json` file and check if `@adonisjs/shield` is registered under the providers array or not.

```json{5}
{
  "providers": [
    "@adonisjs/core",
    "@adonisjs/session",
    "@adonisjs/shield"
  ]
}
```

[note]
Shield provider relies on [Sessions](sessions#setup), so make sure that the session package is installed and configured.
[/note]


### Install the Package
Install the `@adonisjs/shield` package from npm registry using the following command.

[codegroup]
```sh{}{npm}
npm i @adonisjs/shield@alpha
```

```sh{}{yarn}
yarn add @adonisjs/shield@alpha
```
[/codegroup]

### Invoke Generator
AdonisJS packages can configure themselves by running the post install instructions. Run the following command to setup `@adonisjs/shield` package.

```sh
node ace invoke @adonisjs/shield

#    create    config/shield.ts
#    update    tsconfig.json
#    update    .adonisrc.json
# âœ”  create    ace-manifest.json
```

## CSRF Protection
Cross-site request forgery (CSRF) is a very common web attack, in which an attacker can trick a user to submit forms without their consent. In order to prevent this attack, AdonisJS expects a token to be present during all form submissions, otherwise it will deny the request.

[tip]
We recommend you to also [read this article](https://blog.codinghorror.com/preventing-csrf-and-xsrf-attacks/) to have a better understanding of the CSRF attack.
[/tip]

- The CSRF token generated by AdonisJS is cryptographically secure. It means, an attacker cannot generate it randomly.
- During form submissions, AdonisJS expects a valid CSRF token to exist.
- You (the website creator) can access the token on server side and place it as a hidden field within the form.
- The attacker doesn't have access to the CSRF token and hence their malicious form submissions will be denied right away.

### Usage
When creating a new form, you can access the CSRF token using the `csrfField` view global method.

```edge{2}
<form method="POST" action="posts">
  {{ csrfField() }}

  <div>
    <label for="title"> Post title </label>
    <input type="text" name="title" />
  </div>
</form>
```

[video url="https://res.cloudinary.com/adonis-js/video/upload/q_80/v1583993489/adonisjs.com/csrf-protection_lspjgi.mp4", controls]

### SPA Form Submissions
The forms created using a frontend framework like React, Vue or Angular are rendered on client side and doesn't have access to the CSRF token.

If your SPA is running on the same domain as your AdonisJS web server, then you can rely on the `XSRF-TOKEN` cookie to read the CSRF token and send it back as `X-XSRF-TOKEN` header.

Following is an example of using the cookie with axios.

```ts
axios.post('posts', {
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
})
```

## XSS Protection
Cross-site scripting (XSS) attacks enable attackers to inject client-side scripts into web pages viewed by other users. 

By default, protection against such attacks is enabled. You can change this behavior by updating the `xss.enabled` property in the `config/shield.ts` file.

```ts
export const xss = {
  enabled: true,
  enableOnOldIE: true,
  mode: 'block',
}
```

## Content Security Policy
The `Content-Security-Policy` helps prevent unwanted content being injected into your webpages, which inturn reduces the risk of XSS attacks and prevents unwanted trackers or malicious frames from being injected into your webpages.

[tip]
We recommended [reading this article](https://www.html5rocks.com/en/tutorials/security/content-security-policy/) for a better understanding of CSP.
[/tip]

The CSP rules are disabled by default and you must configure them based upon the needs of your application. All the configuration is stored inside `config/shield.ts` file under the `csp` object.

```ts
export const csp = {
  enabled: true,
  directives: {
    styleSrc: ['self', '@nonce', 'cdnjs.cloudfare.com']
  }
}
```

### Supported Directives
Following is the list of supported directives. They can appear in both `camelCase` or `kebab-case`.

- `base-uri` or `baseUri`
- `block-all-mixed-content` or `blockAllMixedContent`
- `child-src` or `childSrc`
- `connect-src` or `connectSrc`
- `default-src` or `defaultSrc`
- `font-src` or `fontSrc`
- `form-action` or `formAction`
- `frame-ancestors` or `frameAncestors`
- `frame-src` or `frameSrc`
- `img-src` or `imgSrc`
- `manifest-src` or `manifestSrc`
- `media-src` or `mediaSrc`
- `object-src` or `objectSrc`
- `plugin-types` or `pluginTypes`
- `prefetch-src` or `prefetchSrc`
- `report-to` or `reportTo`
- `report-uri` or `reportUri`
- require-sri-for `or `requireSriFor`
- `sandbox` or `sandbox`
- `script-src` or `scriptSrc`
- `style-src` or `styleSrc`
- `upgrade-insecure-requests` or `upgradeInsecureRequests`
- `worker-src` or `workerSrc`

## HTTP Strict Transport Security
The HSTS response header instructs the browser that it should only be accessed using the secure HTTPS protocol. This header is enabled by default. You can also control how long the browser should remember that your site should only be accessed over HTTPS.

```ts
export const hsts: ShieldConfig['hsts'] = {
  enabled: true,
  maxAge: '180 days',
}
```

## No Sniff
The majority of modern browsers attempts to detect the `Content-Type` of a request by sniffing its content, meaning a file ending in .txt could be executed as JavaScript if it contains JavaScript code. As a security measure, this behavior is disabled by default by shield. To enable it, modify the `contentTypeSniffing.enabled` property in the `config/shield.ts` file.

```ts
export const contentTypeSniffing: ShieldConfig['contentTypeSniffing'] = {
  enabled: false,
}
```

## No open
IE users can execute webpages in the context of your website, which is a serious security risk. To stop IE from executing unknown scripts in the context of your website, ensure `noOpen.enabled` is set to true (sets the header `X-Download-Options: noopen`). By default, this security measure is not enabled in Shield because not many websites are running IE8 these days.

```ts
export const noOpen: ShieldConfig['noOpen'] = {
  enabled: false,
}
```

## XFrame
The `xFrame` configuration can help you configure external page embed settings for your website. This can help protect your site against [clickjacking](https://en.wikipedia.org/wiki/Clickjacking). The available actions are `DENY`, which does not allow any embeds from any sites, `SAMEORIGIN` which allows embeds only if the page being embedded is from the same origin, and `ALLOW-FROM` which can be used to permit embeds from a specific domain.

```ts
export const xFrame: ShieldConfig['xFrame'] = {
  enabled: true,
  action: 'DENY',
}
```

## DNS Prefetch
The `X-DNS-Prefetch-Control` response header controls DNS prefetching. This is a feature by which browsers perform domain name resolution on links referenced by the document before the user actually gets to clicking on them. This reduces latency when a user clicks on a link. By default this header is always sent alongside the response. To explicitly define the value of the `X-DNS-Prefetch-Control` header, modify the `allow` option. When `dnsPrefetch.allow` is `true`, the header value would be set to `on`, and when `dnsPrefetch.allow` is `false`, the header value would be set to `off`. 

```ts
export const dnsPrefetch: ShieldConfig['dnsPrefetch'] = {
  enabled: true,
  allow: true
}
```
